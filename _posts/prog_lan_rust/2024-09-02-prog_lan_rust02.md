---

title: "Rust"
subtitle: "Rust"
layout: post
author: "orgaworl"
header-style: text
tags:
   - Rust
   - ç¼–ç¨‹è¯­è¨€
  - é™æ€è¯­è¨€
  - é¢å‘å¯¹è±¡
  - ç‰©ç†æœºè¿è¡Œ
  - code
  - rust
---




## è¯­æ³•
### 01æ•°æ®ç±»å‹
#### åŸºæœ¬æ•°æ®ç»“æ„

- integer
  `isize,usize`
	`65535u16`

- float
  `f32,f64`
	é»˜è®¤`f64`
- bool
  å€¼ä¸º `true,false`

- char
	4Byteå¤§å°ï¼Œè¡¨ç¤ºUnicodeæ ‡é‡å€¼, ä½¿ç”¨`'`è¿›è¡Œæ ‡è¯†


#### å¤æ‚æ•°æ®ç»“æ„

##### å•å…ƒç±»å‹ `()`
ä¸€ä¸ªç‰¹æ®Šçš„ç±»å‹ï¼Œé€šå¸¸ç”¨äºè¡¨ç¤ºæ²¡æœ‰æœ‰æ„ä¹‰çš„å€¼æˆ–è€…ä¸è¿”å›ä»»ä½•å€¼çš„æƒ…å†µã€‚å®ƒæ˜¯ Rust ä¸­æœ€ç®€å•çš„ç±»å‹ä¹‹ä¸€ï¼Œå®é™…ä¸Šåªæœ‰ä¸€ä¸ªå¯èƒ½çš„å€¼â€”â€”å•å…ƒå€¼ `()`

- **å•å…ƒç±»å‹**æ˜¯ä¸€ä¸ªè¡¨ç¤ºâ€œç©ºâ€æˆ–â€œæ²¡æœ‰å€¼â€çš„ç±»å‹ã€‚
- å®ƒçš„å”¯ä¸€å€¼æ˜¯ `()`ï¼Œè¿™æ˜¯ä¸€ä¸ªè¡¨ç¤ºæ— è¿”å›å€¼çš„å ä½ç¬¦ã€‚
- å¦‚æœä¸€ä¸ªå‡½æ•°æ²¡æœ‰æ˜¾å¼è¿”å›å€¼ï¼Œå®ƒé»˜è®¤è¿”å›å•å…ƒç±»å‹ `()`
- **å¤§å°**ï¼š`()` ç±»å‹çš„å¤§å°æ˜¯ 0ï¼Œå› ä¸ºå®ƒæ²¡æœ‰å®é™…çš„æ•°æ®ã€‚
- **ä¸å¯å˜**ï¼š`()` ç±»å‹çš„å€¼ä¸èƒ½æ”¹å˜ï¼Œå› ä¸ºå®ƒåªæœ‰ä¸€ä¸ªå€¼ï¼Œå³ `()`ã€‚
- **ä¸å…¶ä»–ç±»å‹çš„å…³ç³»**ï¼šå•å…ƒç±»å‹é€šå¸¸ä¸ä¼šä¸å…¶ä»–ç±»å‹ç›´æ¥è½¬æ¢ï¼Œä½†å®ƒæ˜¯è®¸å¤šå‡½æ•°å’Œæ“ä½œçš„é»˜è®¤è¿”å›ç±»å‹ã€‚


```rust
use std::mem::size_of_val;
fn main() {
    let unit: () = ();
    assert!(size_of_val(&unit) == 0);
    assert_eq!(unit, implicitly_ret_unit());
}
fn implicitly_ret_unit() {
    println!("I will return a ()")
}
```

##### ä¸å¯è¾¾ç±»å‹ `!`
- **å®šä¹‰**ï¼š`!` æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„ç±»å‹ï¼Œç”¨äºè¡¨ç¤ºä¸€ä¸ªå‡½æ•°æ°¸è¿œä¸ä¼šè¿”å›ã€‚è¿™ç§ç±»å‹çš„å‡½æ•°è¦ä¹ˆé™·å…¥æ— é™å¾ªç¯ï¼Œè¦ä¹ˆåœ¨æŸä¸ªç‚¹ç»ˆæ­¢æ•´ä¸ªç¨‹åºã€‚
    
- **ç”¨é€”**ï¼šä¸»è¦ç”¨äºæ ‡è¯†é‚£äº›ä¸ä¼šæ­£å¸¸è¿”å›çš„å‡½æ•°ï¼Œä¾‹å¦‚ï¼š
```rust
fn loop_forever() -> ! {
    loop {
        // æ°¸è¿œå¾ªç¯
    }
}
fn panic_now() -> ! {
    panic!("This function will not return");
}

```

**å‘æ•£å‡½æ•°**( Diverging function )ä¸ä¼šè¿”å›ä»»ä½•å€¼ï¼Œå› æ­¤å®ƒä»¬å¯ä»¥ç”¨äºæ›¿ä»£éœ€è¦è¿”å›ä»»ä½•å€¼çš„åœ°æ–¹,å…¶è¿”å›å€¼æ˜¯`!`.





##### å…ƒç»„ Â `(T1, T2, ...)`
å…ƒç»„æ˜¯ç”¨ä¸€å¯¹Â ( )Â åŒ…æ‹¬çš„ä¸€ç»„æ•°æ®ï¼Œå¯ä»¥åŒ…å«ä¸åŒç§ç±»çš„æ•°æ®ï¼š

åˆå§‹åŒ–
```rust
let tup:(i32,i64,u8)=(500,6.4,1);
let (x,y,z)=tup;          //é»˜è®¤ä¸ºä¸å¯å˜å˜é‡
let (mut x,mut y)=(1,1);
```

å…ƒç»„å¯ä»¥åµŒå¥—å…ƒç»„
```rust

```


è®¿é—®: 
```rust
// ä½¿ç”¨ä¸‹æ ‡åšæ–¹æ³•
tup.0


// ä½¿ç”¨æ¨¡å¼åŒ¹é…æ¥è§£æ„å…ƒç»„
let tup = (1, 6.4, "hello");
let (x,z,y) = tup;

//è§£æ„å¼èµ‹å€¼
let (x, y, z);
(y,z,x) = (1, 2, 3);


```

åšå‡½æ•°å‚æ•°ä¸è¿”å›å€¼
```rust
fn main() {
    let (x, y) = sum_multiply( (2,3) );
}
fn sum_multiply(nums: (i32, i32)) -> (i32, i32) {
    (nums.0 + nums.1, nums.0 * nums.1)
}
```


å¯¹è¾“å‡ºå…ƒç»„å…ƒç´ ä¸ªæ•°æœ‰é™åˆ¶, æœ€å¤šè¾“å‡ºæ‹¥æœ‰**12ä¸ªå…ƒç´ **çš„å…ƒç»„


##### æ•°ç»„ `[T; Length]` 
è¦æ±‚æ•°ç»„é•¿åº¦ç¼–è¯‘æ—¶å·²çŸ¥, åˆ†é…åœ¨æ ˆä¸Š.

- åˆå§‹åŒ–
	```rust
	let c: [_; 5] = [1, 2, 3, 4, 5]; //è‡ªåŠ¨æ¨æ–­ç±»å‹
	let c: [i32; 5] = [1, 2, 3, 4, 5];
	let d: [i32;repeatTime] = [val; repeatTime]; 
	```

- é€šè¿‡ä¸‹æ ‡è®¿é—®, è¶Šç•Œæ—¶ä¼šè§¦å‘`panic`
	```rust
	let val=d[0];
	```
- é€šè¿‡`.get(nth)`è®¿é—®
	```rust
	let name0 = names.get(0).unwrap();
	```

##### å­—ç¬¦ä¸²
- str 
	æ­£å¸¸æƒ…å†µä¸‹æˆ‘ä»¬æ— æ³•ä½¿ç”¨Â `str`Â ç±»å‹, ä½¿ç”¨éœ€è¦é…åˆ`Box<str>`
	```rust
	fn main() {
	    let s: Box<str> = "hello, world".into();
	    greetings(&s)
	}
	fn greetings(s: &str) {}
	```
	
	```rust
	fn main() {
	    let s: Box<&str> = "hello, world".into();
	    greetings(*s)
	}
	fn greetings(s: &str) {}
	```

- &str  16Byte poi+len
	æ˜¯`String`çš„å­é›†, åªè¯»çš„å­—ç¬¦ä¸²æŒ‡é’ˆ
	```rust
	let t:&str="hello";
	let h:String=String::from("hello");
	let d:&str=&h[..]
	let d:&str=&h[0..2]
	
	```

- String 24Byte
	å­—ç¬¦ä¸²æ™ºèƒ½æŒ‡é’ˆ,ç®¡ç†é¢å¤–æ•°æ®
	```rust
	let mut string = String::new();
	let mut string = String::from("");
	let mut string = String::with_capacity(cap);
	let mut string = val.to_string();
	
	.push_str(str);
	.push(char);
	.len(); // å­—èŠ‚é•¿åº¦
	.chars().count(); //å­—ç¬¦é•¿åº¦
	.as_bytes()       //æ‰€æœ‰æƒä»ä¿ç•™
	.into_bytes()     //æ‰€æœ‰æƒèµ‹äºˆç»™æ–¹æ³•
	.replace(oriStr,newStr)
	
	```

	å­—ç¬¦ä¸²æ‹¼æ¥
	```rust
	fn main() {
	    let s1 = String::from("hello,");
	    let s2 = String::from("world!");
	    let s3 = s1.clone()  + &s2;
	    // å…ˆåˆ›å»ºå¤åˆ¶Stringå¯¹è±¡,å†åœ¨å¤åˆ¶å¯¹è±¡åé¢è¿½åŠ å†…å®¹
	    assert_eq!(s3,"hello,world!");
	    println!("{}",s1);
	}
	```


å­—ç¬¦ä¸²ç´¢å¼•: 

- æŒ‰å­—èŠ‚è¿›è¡Œç´¢å¼•
	```rust
	let s1 = String::from("hi,ä¸­å›½");
	let h = &s1[0..1]; // `h` å­—ç¬¦åœ¨ UTF-8 æ ¼å¼ä¸­åªéœ€è¦ 1 ä¸ªå­—èŠ‚æ¥è¡¨ç¤º
	assert_eq!(h, "h");

	let h1 = &s1[3..6];// `ä¸­` å­—ç¬¦åœ¨ UTF-8 æ ¼å¼ä¸­éœ€è¦ 3 ä¸ªå­—èŠ‚æ¥è¡¨ç¤º
	assert_eq!(h1, "ä¸­");
	```
- æŒ‰å­—ç¬¦è¿›è¡Œç´¢å¼•
	```rust
	use utf8_slice;
	fn main() {
	    let s = "The ğŸš€ goes to the ğŸŒ‘!";
	    let rocket = utf8_slice::slice(s, 4, 5);
	    // ç»“æœæ˜¯ "ğŸš€"
	}
	```

```rust
for c in "ä½ å¥½ï¼Œä¸–ç•Œ".chars(){
}
```

ç±»å‹è½¬æ¢
- `String` => `&str`
```rust
var.as_str();

let s1: &str = &var;

```

- `String` <= `&str`
```rust
String::from(var:&str)
var.to_string()

```

- `&String`Â å¯ä»¥è¢«éšå¼åœ°è½¬æ¢æˆÂ `&str`Â ç±»å‹.

##### å­—ç¬¦ä¸²è½¬ä¹‰

è½¬ä¹‰
- `\\`è¡¨ç¤º`\`
- `\"`è¡¨ç¤º`"`
- `\x41` ä½¿ç”¨åå…­è¿›åˆ¶çš„å€¼
- `\u{211D}` ä½¿ç”¨ Unicode å½¢å¼çš„è½¬ä¹‰å­—ç¬¦
- ä½¿ç”¨`\` æ¥è¿æ¥å¤šè¡Œå­—ç¬¦ä¸²

raw string
- `r" "` 
- `r#" "#` ä½¿ç”¨åŒå¼•å·
- `r###"  "###` ä½¿ç”¨ # å·

```rust
fn main() {
    let raw_str = r"Escapes don't work here: ? â„";
    assert_eq!(raw_str, "Escapes don't work here: ? â„");
    let quotes = r#"And then I said: "There is no escape!""#;
    let  delimiter = r###"A string with "# in it. And even "##!"###;
    
    let long_delimiter = r###"Hello, "##""###;
    assert_eq!(long_delimiter, "Hello, \"##\"")
}
```

##### å­—èŠ‚æ•°ç»„ `&[u8; len]`
å¯ä»¥å°†å­—ç¬¦ä¸²æŒ‰å­—èŠ‚è¿›è¡Œè½¬ä¹‰,ä¿å­˜åˆ°å­—èŠ‚æ•°ç»„ä¸­
å­—èŠ‚æ•°ç»„ä¸­å†…å®¹å¯ä»¥ä¸æ˜¯UTF-8ç¼–ç 
æ‰€ä»¥å°†å­—èŠ‚æ•°ç»„è½¬æˆ `str` ç±»å‹å¯èƒ½ä¼šå¤±è´¥
```rust
    if let Ok(my_str) = str::from_utf8(raw_bytestring) {
        println!("And the same as text: '{}'", my_str);
    }
```






##### å‘é‡Vec
```rust
let vector:Vec<type> = Vec::new();
let vector           = Vec![1,2,4,8];
.push(val);
.append(Vec); //å‘é‡æ‹¼æ¥
.get(val);    //è¿”å›æšä¸¾ç±»

```

##### HashMap
```rust
letÂ mutÂ mapÂ =Â HashMap::new();  
map.insert("color",Â "red");          //ç›´æ¥æ’å…¥
map.insert("size",Â "10 m^2");
map.get("color").unwrap()
map.entry("color").or_insert("red"); //å®‰å…¨æ’å…¥
```



##### åˆ‡ç‰‡(å¼•ç”¨) Slice `&[T]`
>åˆ‡ç‰‡çš„é•¿åº¦æ— æ³•åœ¨ç¼–è¯‘æœŸå¾—çŸ¥, å› æ­¤æ— æ³•ç›´æ¥ä½¿ç”¨åˆ‡ç‰‡ç±»å‹, äº‹å®ä¸Šä½¿ç”¨çš„æ˜¯åˆ‡ç‰‡å¼•ç”¨, è€Œéç±»å‹æœ¬èº«.
>å®è´¨æ˜¯ä¸€ä¸ªèƒ–æŒ‡é’ˆ, ä¸€ä¸ªåˆ‡ç‰‡å¼•ç”¨å ç”¨äº†2ä¸ªå­—å¤§å°çš„å†…å­˜ç©ºé—´,åŒ…å«æŒ‡é’ˆå’Œé•¿åº¦å­—.

åˆ‡ç‰‡( å¼•ç”¨ )å¯ä»¥ç”¨æ¥å€Ÿç”¨æ•°ç»„çš„æŸä¸ªè¿ç»­çš„éƒ¨åˆ†ï¼Œå¯¹åº”çš„ç­¾åæ˜¯Â `&[T]`ï¼Œæ•°ç»„çš„ç­¾åÂ `[T; Length]`ã€‚

```rust
let slice=&vec[0..n]


```


`str` å’Œ`String`éƒ½æ”¯æŒåˆ‡ç‰‡æ“ä½œ

### 02å˜é‡å¸¸é‡

- å¸¸é‡
- ä¸å¯å˜å˜é‡
- å¯å˜å˜é‡
>å˜é‡å¿…é¡»ç»è¿‡åˆå§‹åŒ–æ‰èƒ½ä½¿ç”¨

```rust
let a = 123;       //ä¸å¯å˜å˜é‡
let mut a = 123;   //å¯å˜å˜é‡
const a: i32 = 123;//å¸¸é‡ 
```

å¸¸é‡ä¸ä¸å¯å˜å˜é‡çš„åŒºåˆ«
- å˜é‡çš„å€¼å¯ä»¥"é‡æ–°ç»‘å®š"ï¼Œä½†åœ¨"é‡æ–°ç»‘å®š"ä»¥å‰ä¸èƒ½ç§è‡ªè¢«æ”¹å˜
- å¸¸é‡çš„å€¼æ°¸è¿œä¸å¯æ”¹å˜
#### é®æ–­ï¼ˆShadowingï¼‰
é‡å½±å°±æ˜¯æŒ‡å˜é‡çš„åç§°å¯ä»¥è¢«é‡æ–°ä½¿ç”¨çš„æœºåˆ¶ï¼š

Shadowingä¸èµ‹å€¼çš„å¯¹æ¯”**
- Shadowingæ˜¯æŒ‡ç”¨åŒä¸€ä¸ªåå­—é‡æ–°ä»£è¡¨å¦ä¸€ä¸ªå˜é‡å®ä½“ï¼Œå…¶ç±»å‹ã€å¯å˜å±æ€§å’Œå€¼éƒ½å¯ä»¥å˜åŒ–ã€‚
- å¯å˜å˜é‡èµ‹å€¼ä»…èƒ½å‘ç”Ÿå€¼çš„å˜åŒ–

```rust
fn main() {
    let x: i32 = 5;
    {
        let x = 12;
        assert_eq!(x, 12);
    }
    assert_eq!(x, 5);

    let x = 42;
    println!("{}", x); // è¾“å‡º "42".
}
```

```rust
    let mut x: i32 = 1;
    x = 7;
    let mut x = x; // é®è”½ä¸”å†æ¬¡ç»‘å®š, å¿…é¡»ä¸ºmutç±»å‹
    x += 3;
```

#### è§£æ„å¼èµ‹å€¼
å¯ä»¥åœ¨èµ‹å€¼è¯­å¥çš„å·¦å¼ä¸­ä½¿ç”¨å…ƒç»„ã€åˆ‡ç‰‡æˆ–ç»“æ„ä½“è¿›è¡ŒåŒ¹é…èµ‹å€¼ã€‚
```rust
fn main() {
    let (x, y);
    (x,..) = (3, 4);
    [.., y] = [1, 2];
    assert_eq!([x,y], [3,2]);
} 
```



### 04è¿ç®—

```rust
= //èµ‹å€¼
```

#### æµ®ç‚¹æ•°è®¡ç®—æŸå¤±

```rust
std::f32::EPSILON

```


#### æ•´æ•°æº¢å‡º

æ‰‹åŠ¨ç¯ç»•è¿ç®—
`let sum = x.wrapping_add(y);`

é¥±å’Œè¿ç®—: æº¢å‡ºæ—¶è¿”å›æœ€å¤§å€¼æˆ–æœ€å°å€¼
`let sum = x.saturating_add(y);`

#### æ˜¾å¼ç±»å‹è½¬æ¢

```rust
let a: u32 = 10;
let b = a as u64;
let c: u64 = a as _;  // è‡ªåŠ¨æ¨æ–­
```




### 05å‡½æ•°ä¸è¯­å¥å—

```rust
//å‡½æ•°
fn <funcName> (varName:varType,)->resType{
    ......
    return res;
}

//è¯­å¥å—
//æœ€åä¸€ä¸ªæ­¥éª¤æ˜¯è¡¨è¾¾å¼ï¼Œæ­¤è¡¨è¾¾å¼çš„ç»“æœå€¼æ˜¯æ•´ä¸ªè¡¨è¾¾å¼å—æ‰€ä»£è¡¨çš„å€¼
let res={
         ;
    value  
};
```

ç‰¹ç‚¹
- å®šä¹‰ä½ç½®æ— è¦æ±‚
- å‡½æ•°å‚æ•°å¿…é¡»å£°æ˜ç±»å‹
- Â ä¸æ”¯æŒè‡ªåŠ¨è¿”å›å€¼ç±»å‹åˆ¤æ–­ï¼ŒæœªæŒ‡å®šè¿”å›å€¼ç±»å‹åˆ™ä¸å…è®¸è¿”å›å€¼

---

### 06æµç¨‹æ§åˆ¶

```rust
//æ¡ä»¶è¡¨è¾¾å¼å¿…é¡»æ˜¯ bool ç±»å‹,blockå¯ä»¥æ˜¯å‡½æ•°ä½“è¡¨è¾¾å¼
if condition {block1}
else if condition {block2}
else {block3}

while condition {block}

for i in iterObj {block}

loop {block} //æ— é™å¾ªç¯
```

```rust
break;
break value; // å¯ä»¥ç»“åˆå¾ªç¯å’Œbreak, å®ç°è¿”å›å€¼çš„æ•ˆæœ
continue;

```

å¤šå±‚`loop`æ—¶,å¯ä¸ºæ¯å±‚`loop`æ·»åŠ æ ‡ç­¾, å®ç°æ§åˆ¶å¤–å±‚æµçš„æ•ˆæœ

```rust
let mut count = 0;
'outer: loop {
	'inner1: loop {
		if count >= 20 {
			break 'inner1;
		}
		count += 2;
	}

	count += 5;

	'inner2: loop {
		if count >= 30 {
			break 'outer;
		}
		continue 'outer;
	}
}

```



---

author email: orgaworl@outlook.com
